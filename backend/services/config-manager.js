#!/usr/bin/env node

/**
 * Configuration Manager Service
 * 
 * Automatically regenerates go2rtc.yaml and restarts go2rtc when camera settings change.
 * This makes the system seamless for users - they just update settings in the UI
 * and the streams automatically update.
 */

import { exec, spawn } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import Database from 'better-sqlite3';
import yaml from 'js-yaml';
import { detectHardwareEncoder } from '../scripts/detect-hardware-encoder.js';

const execAsync = promisify(exec);
const __dirname = path.dirname(fileURLToPath(import.meta.url));

class ConfigManager {
  constructor(options = {}) {
    this.dbPath = options.dbPath || path.join(__dirname, '../db/config.db');
    this.go2rtcConfigPath = options.go2rtcConfigPath || path.join(__dirname, '../../go2rtc.yaml');
    this.go2rtcBinaryPath = options.go2rtcBinaryPath || path.join(__dirname, '../../go2rtc');
    this.go2rtcProcess = null;
    this.restartTimeout = null;
    this.isRestarting = false;
    
    // Detect hardware encoder once at startup
    this.encoderInfo = detectHardwareEncoder();
    this.selectedEncoder = this.encoderInfo.best;
    console.log(`üé¨ Hardware encoder: ${this.selectedEncoder.displayName} (~${this.selectedEncoder.latencyMs}ms latency)`);
  }

  /**
   * Generate go2rtc.yaml from database configuration
   */
  async generateConfig() {
    console.log('üîß Generating go2rtc.yaml from database...');
    
    try {
      if (!fs.existsSync(this.dbPath)) {
        throw new Error(`Database not found at: ${this.dbPath}`);
      }

      const db = new Database(this.dbPath);
      const sites = db.prepare('SELECT * FROM sites').all();
      db.close();

      if (sites.length === 0) {
        throw new Error('No sites found in database');
      }

      console.log(`Found ${sites.length} site(s) in database`);

      // Generate streams configuration
      const streams = {};

      sites.forEach((site) => {
        // Always use site prefix for consistency with frontend
        const sitePrefix = `site${site.id}_`;
        
        // Parse dewarp parameters
        const dewarpParams = JSON.parse(site.dewarp_params || '{}');
        const { cx = 0.5, cy = 0.5, k1 = -0.23, k2 = -0.02 } = dewarpParams;
        
        // Main stream (raw from camera)
        const mainStreamName = `${sitePrefix}main`;
        streams[mainStreamName] = [site.camera_url];
        
        // Dewarped stream for virtual PTZ
        const dewarpedStreamName = `${sitePrefix}dewarped`;
        
        // Build FFmpeg filter chain
        const filters = [];
        
        // Lens correction (dewarp) - only if enabled
        const enableDewarp = dewarpParams.enable_dewarp !== false;
        
        if (enableDewarp) {
          filters.push(`lenscorrection=cx=${cx}:cy=${cy}:k1=${k1}:k2=${k2}`);
        }
        
        // Optional crop (if specified in dewarp_params)
        if (dewarpParams.crop_x !== undefined) {
          const { crop_x, crop_y, crop_width, crop_height } = dewarpParams;
          filters.push(`crop=${crop_width}:${crop_height}:${crop_x}:${crop_y}`);
        }
        
        // Scale to standard resolution (default: 2K QHD)
        const [width, height] = (site.stream_resolution || '2560x1440').split('x');
        filters.push(`scale=${width}:${height}`);
        
        const filterChain = filters.join(',');
        
        // FFmpeg stream with hardware-accelerated encoding for low latency
        const inputArgs = '-fflags nobuffer+genpts -flags low_delay -probesize 32 -analyzeduration 0';
        streams[dewarpedStreamName] = [
          `ffmpeg:${mainStreamName}#video=h264#raw=${inputArgs} -vf ${filterChain} ${this.selectedEncoder.args}`
        ];
      });

      // Build complete configuration
      const config = {
        streams,
        webrtc: {
          listen: ':8555',
          ice_servers: [
            {
              urls: ['stun:stun.l.google.com:19302']
            }
          ]
        },
        api: {
          listen: ':1984'
        },
        log: {
          level: 'info'
        }
      };

      // Add header comment
      const header = `# go2rtc Configuration - Auto-generated from database
#
# This file was automatically generated by the Configuration Manager
# Generated: ${new Date().toISOString()}
# Sites configured: ${sites.length}
# Encoder: ${this.selectedEncoder.displayName} (${this.selectedEncoder.encoder})
# Expected transcoding latency: ~${this.selectedEncoder.latencyMs}ms
#
# ‚ö†Ô∏è  WARNING: Manual changes to this file may be overwritten!
# To modify camera configuration, update the database via the API or calibration tool.
#
# The configuration manager will automatically regenerate this file and restart go2rtc
# when changes are detected.
#

`;

      // Generate YAML
      const yamlContent = yaml.dump(config, { indent: 2, lineWidth: -1 });
      const fullContent = header + yamlContent;

      // Backup existing file if it exists
      if (fs.existsSync(this.go2rtcConfigPath)) {
        const backupPath = this.go2rtcConfigPath + '.backup';
        fs.copyFileSync(this.go2rtcConfigPath, backupPath);
      }

      // Write new configuration
      fs.writeFileSync(this.go2rtcConfigPath, fullContent);
      console.log(`‚úÖ Generated go2rtc.yaml with ${Object.keys(streams).length} streams`);
      
      return {
        success: true,
        streamsCount: Object.keys(streams).length,
        sitesCount: sites.length
      };
    } catch (error) {
      console.error('‚ùå Error generating config:', error);
      throw error;
    }
  }

  /**
   * Find go2rtc process ID
   */
  async findGo2rtcProcess() {
    try {
      const { stdout } = await execAsync('pgrep -f "go2rtc.*-config"');
      const pids = stdout.trim().split('\n').filter(pid => pid);
      return pids.length > 0 ? parseInt(pids[0]) : null;
    } catch (error) {
      // pgrep returns exit code 1 if no process found
      return null;
    }
  }

  /**
   * Stop go2rtc process gracefully
   */
  async stopGo2rtc() {
    try {
      const pid = await this.findGo2rtcProcess();
      
      if (!pid) {
        console.log('‚ÑπÔ∏è  go2rtc is not running');
        return { success: true, message: 'Not running' };
      }

      console.log(`üõë Stopping go2rtc (PID: ${pid})...`);
      
      // Try graceful shutdown first (SIGTERM)
      process.kill(pid, 'SIGTERM');
      
      // Wait up to 5 seconds for graceful shutdown
      for (let i = 0; i < 10; i++) {
        await new Promise(resolve => setTimeout(resolve, 500));
        const stillRunning = await this.findGo2rtcProcess();
        if (!stillRunning) {
          console.log('‚úÖ go2rtc stopped gracefully');
          return { success: true, message: 'Stopped gracefully' };
        }
      }

      // If still running, force kill
      console.log('‚ö†Ô∏è  Forcing go2rtc shutdown...');
      process.kill(pid, 'SIGKILL');
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      console.log('‚úÖ go2rtc stopped (forced)');
      return { success: true, message: 'Stopped (forced)' };
    } catch (error) {
      console.error('‚ùå Error stopping go2rtc:', error);
      throw error;
    }
  }

  /**
   * Start go2rtc process
   */
  async startGo2rtc() {
    try {
      if (!fs.existsSync(this.go2rtcBinaryPath)) {
        throw new Error(`go2rtc binary not found at: ${this.go2rtcBinaryPath}`);
      }

      if (!fs.existsSync(this.go2rtcConfigPath)) {
        throw new Error(`go2rtc config not found at: ${this.go2rtcConfigPath}`);
      }

      console.log('üöÄ Starting go2rtc...');
      
      // Start go2rtc in background
      const go2rtcDir = path.dirname(this.go2rtcBinaryPath);
      const configFilename = path.basename(this.go2rtcConfigPath);
      
      const child = spawn(this.go2rtcBinaryPath, ['-config', configFilename], {
        cwd: go2rtcDir,
        detached: true,
        stdio: 'ignore'
      });

      child.unref();

      // Wait a moment and check if it started
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const pid = await this.findGo2rtcProcess();
      if (pid) {
        console.log(`‚úÖ go2rtc started (PID: ${pid})`);
        return { success: true, pid, message: 'Started successfully' };
      } else {
        throw new Error('go2rtc failed to start');
      }
    } catch (error) {
      console.error('‚ùå Error starting go2rtc:', error);
      throw error;
    }
  }

  /**
   * Restart go2rtc with new configuration
   */
  async restartGo2rtc() {
    if (this.isRestarting) {
      console.log('‚è≥ Restart already in progress, skipping...');
      return { success: false, message: 'Restart already in progress' };
    }

    try {
      this.isRestarting = true;
      console.log('üîÑ Restarting go2rtc...');
      
      await this.stopGo2rtc();
      await new Promise(resolve => setTimeout(resolve, 1000)); // Brief pause
      await this.startGo2rtc();
      
      console.log('‚úÖ go2rtc restarted successfully');
      return { success: true, message: 'Restarted successfully' };
    } catch (error) {
      console.error('‚ùå Error restarting go2rtc:', error);
      throw error;
    } finally {
      this.isRestarting = false;
    }
  }

  /**
   * Full configuration update: regenerate config and restart go2rtc
   * Debounced to avoid multiple rapid restarts
   */
  async updateConfiguration({ debounceMs = 2000 } = {}) {
    // Clear any pending restart
    if (this.restartTimeout) {
      clearTimeout(this.restartTimeout);
    }

    return new Promise((resolve, reject) => {
      this.restartTimeout = setTimeout(async () => {
        try {
          console.log('\n' + '='.repeat(60));
          console.log('üîß CONFIGURATION UPDATE TRIGGERED');
          console.log('='.repeat(60));
          
          // Step 1: Regenerate configuration
          const configResult = await this.generateConfig();
          
          // Step 2: Restart go2rtc
          const restartResult = await this.restartGo2rtc();
          
          console.log('='.repeat(60));
          console.log('‚úÖ CONFIGURATION UPDATE COMPLETE');
          console.log(`   Sites: ${configResult.sitesCount}`);
          console.log(`   Streams: ${configResult.streamsCount}`);
          console.log('='.repeat(60) + '\n');
          
          resolve({
            success: true,
            config: configResult,
            restart: restartResult
          });
        } catch (error) {
          console.error('‚ùå Configuration update failed:', error);
          reject(error);
        }
      }, debounceMs);
    });
  }

  /**
   * Health check - verify go2rtc is running and accessible
   */
  async healthCheck() {
    try {
      const pid = await this.findGo2rtcProcess();
      
      if (!pid) {
        return {
          success: false,
          status: 'not_running',
          message: 'go2rtc process not found'
        };
      }

      // Try to hit the API
      try {
        const response = await fetch('http://localhost:1984/api/streams');
        if (response.ok) {
          const streams = await response.json();
          return {
            success: true,
            status: 'healthy',
            pid,
            streamsCount: Object.keys(streams).length,
            message: 'go2rtc is running and responding'
          };
        }
      } catch (fetchError) {
        return {
          success: false,
          status: 'process_running_api_unavailable',
          pid,
          message: 'go2rtc process found but API not responding'
        };
      }

      return {
        success: false,
        status: 'unknown',
        pid,
        message: 'go2rtc status unknown'
      };
    } catch (error) {
      return {
        success: false,
        status: 'error',
        message: error.message
      };
    }
  }
}

// Export singleton instance
export const configManager = new ConfigManager();
export default ConfigManager;

